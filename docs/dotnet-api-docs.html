<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>.NET API Docs | docfx </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content=".NET API Docs | docfx ">
      
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      <meta name="docfx:rel" content="../">
      
      
      <meta name="docfx:docurl" content="https://github.com/dotnet/docfx/blob/main/docs/docs/dotnet-api-docs.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:copy" content="Copy">
  </head>

  <script type="module">
    import options from './../public/main.js'
    import { init } from './../public/docfx.min.js'
    init(options)
  </script>

  <script>
    const theme = localStorage.getItem('theme') || 'auto'
    document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
  </script>

  <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Q5N6XJHEX5"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-Q5N6XJHEX5');
  </script>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../logo.svg" alt="docfx">
            docfx
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="net-api-docs">.NET API Docs</h1>

<p>Docfx converts <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc/">XML documentation comments</a> into rendered HTML documentations.</p>
<h2 id="generate-net-api-docs">Generate .NET API Docs</h2>
<p>To add API docs for a .NET project, add a <code>metadata</code> section before the <code>build</code> section in <code>docfx.json</code> config:</p>
<pre><code class="lang-json">{
  &quot;metadata&quot;: {
    &quot;src&quot;: [{
      &quot;files&quot;: [&quot;**/bin/Release/**.dll&quot;],
      &quot;src&quot;: &quot;../&quot;
    }],
    &quot;dest&quot;: &quot;api&quot;
  },
  &quot;build&quot;: {
    &quot;content&quot;: [{
      &quot;files&quot;: [ &quot;api/*.yml&quot; ]
    }]
  }
}
</code></pre>
<p>Docfx generates .NET API docs in 2 stages:</p>
<ol>
<li>The <em>metadata</em> stage uses the <code>metadata</code> config to produce <a href="dotnet-yaml-format.html">.NET API YAML files</a> at the <code>metadata.dest</code> directory.</li>
</ol>
<div class="NOTE">
<h5>Note</h5>
<p>The <a href="../api/Docfx.Docset.html"><code>Docset.Build</code></a> method does not run the <em>metadata</em> stage,
invoke the <a href="../api/Docfx.Dotnet.DotnetApiCatalog.html"><code>DotnetApiCatalog.GenerateManagedReferenceYamlFiles</code></a> method to run the <em>metadata</em> stage before the <em>build</em> stage.</p>
</div>
<ol start="2">
<li>The <em>build</em> stage transforms the generated .NET API YAML files specified in <code>build.content</code> config into HTML files.</li>
</ol>
<p>These 2 stages can run independently with the <code>docfx metadata</code> command and the <code>docfx build</code> command. The <code>docfx</code> root command runs both <code>metadata</code> and <code>build</code>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Glob patterns in docfx currently does not support crawling files outside the directory containing <code>docfx.json</code>. Use the <code>metadata.src.src</code> property</p>
</div>
<p>Docfx supports several source formats to generate .NET API docs:</p>
<h2 id="generate-from-assemblies">Generate from assemblies</h2>
<p>When the file extension is <code>.dll</code> or <code>.exe</code>, docfx produces API docs by reflecting the assembly and the side-by-side XML documentation file.</p>
<p>This approach is build independent and language independent, if you are having trouble with msbuild or using an unsupported project format such as <code>.fsproj</code>, generating docs from assemblies is the recommended approach.</p>
<p>Docfx examines the assembly and tries to load the reference assemblies from within the same directory or the global systems assembly directory. In case an reference assembly fails to resolve, use the <code>references</code> property to specify a list of additional reference assembly path:</p>
<pre><code class="lang-json">{
  &quot;metadata&quot;: {
    &quot;src&quot;: [{
      &quot;files&quot;: [&quot;**/bin/Release/**.dll&quot;],
      &quot;src&quot;: &quot;../&quot;
    }],
    &quot;dest&quot;: &quot;api&quot;,
    &quot;references&quot;: [
      &quot;path-to-reference-assembly.dll&quot;
    ]
  },
}
</code></pre>
<p>If <a href="https://learn.microsoft.com/en-us/dotnet/standard/library-guidance/sourcelink">source link</a> is enabled on the assembly and the <code>.pdb</code> file exists along side the assembly, docfx shows the &quot;View Source&quot; link based on the source URL extract from source link.</p>
<h2 id="generate-from-projects-or-solutions">Generate from projects or solutions</h2>
<p>When the file extension is <code>.csproj</code>, <code>.vbproj</code> or <code>.sln</code>, docfx uses <a href="https://gist.github.com/DustinCampbell/32cd69d04ea1c08a16ae5c4cd21dd3a3"><code>MSBuildWorkspace</code></a> to perform a design-time build of the projects before generating API docs.</p>
<p>In order to successfully load an MSBuild project, .NET Core SDK must be installed and available globally. The installation must have the necessary workloads and components to support the projects you'll be loading.</p>
<p>Run <code>dotnet restore</code> before <code>docfx</code> to ensure that dependencies are available. Running <code>dotnet restore</code> is still needed even if your project does not have NuGet dependencies when Visual Studio is not installed.</p>
<p>To troubleshoot MSBuild load problems, run <code>docfx metadata --logLevel verbose</code> to see MSBuild logs.</p>
<p>Docfx build the project using <code>Release</code> config by default, additional MSBuild properties can be specified with <code>properties</code>.</p>
<p>If your project targets multiple target frameworks, docfx internally builds each target framework of the project. Try specify the <code>TargetFramework</code> MSBuild property to speed up project build:</p>
<pre><code class="lang-json">{
  &quot;metadata&quot;: {
    &quot;src&quot;: [{
      &quot;files&quot;: [&quot;**/bin/Release/**.dll&quot;],
      &quot;src&quot;: &quot;../&quot;
    }],
    &quot;dest&quot;: &quot;api&quot;,
    &quot;properties&quot;: {
      &quot;TargetFramework&quot;: &quot;net6.0&quot;
    }
  },
}
</code></pre>
<h2 id="generate-from-source-code">Generate from source code</h2>
<p>When the file extension is <code>.cs</code> or <code>.vb</code>, docfx uses the latest supported .NET Core SDK installed on the machine to build the source code using <code>Microsoft.NET.Sdk</code>. Additional references can be specified in the <code>references</code> config:</p>
<pre><code class="lang-json">{
  &quot;metadata&quot;: {
    &quot;src&quot;: [{
      &quot;files&quot;: [&quot;**/bin/Release/**.dll&quot;],
      &quot;src&quot;: &quot;../&quot;
    }],
    &quot;dest&quot;: &quot;api&quot;,
    &quot;references&quot;: [
      &quot;path-to-reference-assembly.dll&quot;
    ]
  },
}
</code></pre>
<h2 id="customization-options">Customization Options</h2>
<p>There are several options available for customizing .NET API pages that are tailored to your specific needs and preferences. To customize .NET API pages for DocFX, you can use the following options:</p>
<ul>
<li><p><code>memberLayout</code>: This option determines whether type members should be on the same page as containing type or as dedicated pages. Possible values are:</p>
<ul>
<li><code>samePage</code>: Type members are on the same page as containing type.</li>
<li><code>separatePages</code>: Type members are on dedicated pages.</li>
</ul>
</li>
<li><p><code>namespaceLayout</code>: This option determines whether namespace node in TOC is a list or nested. Possible values are:</p>
<ul>
<li><code>flattened</code>: Namespace node in TOC is a list.</li>
<li><code>nested</code>: Namespace node in TOC is nested.</li>
</ul>
</li>
</ul>
<h2 id="supported-xml-tags">Supported XML Tags</h2>
<p>Docfx supports <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/xmldoc/recommended-tags">Recommended XML tags for C# documentation comments</a>.</p>
<div class="WARNING">
<h5>Warning</h5>
<p>Docfx parses XML documentation comment as markdown by default, writing XML documentation comments using markdown may cause rendering problems on places that do not support markdown, like in the Visual Studio intellisense window.</p>
</div>
<p>To disable markdown parsing while processing XML tags, set <code>shouldSkipMarkup</code> to <code>true</code>:</p>
<pre><code class="lang-json">{
  &quot;metadata&quot;: {
    &quot;src&quot;: [{
      &quot;files&quot;: [&quot;**/bin/Release/**.dll&quot;],
      &quot;src&quot;: &quot;../&quot;
    }],
    &quot;dest&quot;: &quot;api&quot;,
    &quot;shouldSkipMarkup&quot;: true
  }
}
</code></pre>
<h2 id="filter-apis">Filter APIs</h2>
<p>Docfx shows only the public accessible types and methods callable from another assembly. It also has a set of <a href="https://github.com/dotnet/docfx/blob/main/src/Docfx.Metadata.ManagedReference.Common/Filters/defaultfilterconfig.yml">default filtering rules</a> that excludes common API patterns based on attributes such as <code>[EditorBrowsableAttribute]</code>.</p>
<p>To disable the default filtering rules, set the <code>disableDefaultFilter</code> property to <code>true</code>.</p>
<p>To show private methods, set the <code>includePrivateMembers</code> config to <code>true</code>. When enabled, internal only langauge keywords such as <code>private</code> or <code>internal</code> starts to appear in the declaration of all APIs, to accurately reflect API accessibility.</p>
<p>There are two ways of customizing the API filters:</p>
<h3 id="custom-with-code">Custom with Code</h3>
<p>To use a custom filtering with code:</p>
<ol>
<li>Use docfx .NET API generation as a NuGet library:</li>
</ol>
<pre><code class="lang-xml">&lt;PackageReference Include=&quot;Docfx.Dotnet&quot; Version=&quot;2.62.0&quot; /&gt;
</code></pre>
<ol start="2">
<li>Configure the filter options:</li>
</ol>
<pre><code class="lang-cs">var options = new DotnetApiOptions
{
    // Filter based on types
    IncludeApi = symbol =&gt; ...

    // Filter based on attributes
    IncludeAttribute = symbol =&gt; ...
}

await DotnetApiCatalog.GenerateManagedReferenceYamlFiles(&quot;docfx.json&quot;, options);
</code></pre>
<p>The filter callbacks takes an <a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.isymbol?view=roslyn-dotnet"><code>ISymbol</code></a> interface and produces an <a href="../api/Docfx.Dotnet.SymbolIncludeState.html"><code>SymbolIncludeState</code></a> enum to choose between include the API, exclude the API or use the default filtering behavior.</p>
<p>The callbacks are raised before applying the default rules but after processing type accessibility rules. Private types and members cannot be marked as include unless <code>includePrivateMembers</code> is true.</p>
<p>Hiding the parent symbol also hides all of its child symbols, e.g.:</p>
<ul>
<li>If a namespace is hidden, all child namespaces and types underneath it are hidden.</li>
<li>If a class is hidden, all nested types underneath it are hidden.</li>
<li>If an interface is hidden, explicit implementations of that interface are also hidden.</li>
</ul>
<h3 id="custom-with-filter-rules">Custom with Filter Rules</h3>
<p>To add additional filter rules, add a custom YAML file and set the <code>filter</code> property in <code>docfx.json</code> to point to the custom YAML filter:</p>
<pre><code class="lang-json">{
  &quot;metadata&quot;: {
    &quot;src&quot;: [{
      &quot;files&quot;: [&quot;**/bin/Release/**.dll&quot;],
      &quot;src&quot;: &quot;../&quot;
    }],
    &quot;dest&quot;: &quot;api&quot;,
    &quot;filter&quot;: &quot;filterConfig.yml&quot; // &lt;-- Path to custom filter config
  }
}
</code></pre>
<p>The filter config is a list of rules. A rule can include or exclude a set of APIs based on a pattern. The rules are processed sequentially and would stop when a rule matches.</p>
<h4 id="filter-by-uid">Filter by UID</h4>
<p>Every item in the generated API docs has a <a href="dotnet-yaml-format.html"><code>UID</code></a> (a unique identifier calculated for each API) to filter against using regular expression. This example uses <code>uidRegex</code> to excludes all APIs whose uids start with <code>Microsoft.DevDiv</code> but not <code>Microsoft.DevDiv.SpecialCase</code>.</p>
<pre><code class="lang-yaml">apiRules:
- include:
    uidRegex: ^Microsoft\.DevDiv\.SpecialCase
- exclude:
    uidRegex: ^Microsoft\.DevDiv
</code></pre>
<h4 id="filter-by-type">Filter by Type</h4>
<p>This example exclude APIs whose uid starts with <code>Microsoft.DevDiv</code> and type is <code>Type</code>:</p>
<pre><code class="lang-yaml">apiRules:
- exclude:
    uidRegex: ^Microsoft\.DevDiv
    type: Type
</code></pre>
<p>Supported value for <code>type</code> are:</p>
<ul>
<li><p><code>Namespace</code></p>
</li>
<li><p><code>Class</code></p>
</li>
<li><p><code>Struct</code></p>
</li>
<li><p><code>Enum</code></p>
</li>
<li><p><code>Interface</code></p>
</li>
<li><p><code>Delegate</code></p>
</li>
<li><p><code>Event</code></p>
</li>
<li><p><code>Field</code></p>
</li>
<li><p><code>Method</code></p>
</li>
<li><p><code>Property</code></p>
</li>
<li><p><code>Type</code>: a <code>Class</code>, <code>Struct</code>, <code>Enum</code>, <code>Interface</code> or <code>Delegate</code>.</p>
</li>
<li><p><code>Member</code>: a <code>Field</code>, <code>Event</code>, <code>Method</code> or <code>Property</code>.</p>
</li>
</ul>
<p>API filter are hierarchical, if a namespace is excluded, all types/members defined in the namespace would also be excluded. Similarly, if a type is excluded, all members defined in the type would also be excluded.</p>
<h4 id="filter-by-attribute">Filter by Attribute</h4>
<p>This example excludes all APIs which have <code>AttributeUsageAttribute</code> set to <code>System.AttributeTargets.Class</code> and the <code>Inherited</code> argument set to <code>true</code>:</p>
<pre><code class="lang-yaml">apiRules:
- exclude:
  hasAttribute:
    uid: System.AttributeUsageAttribute
    ctorArguments:
    - System.AttributeTargets.Class
    ctorNamedArguments:
      Inherited: &quot;true&quot;
</code></pre>
<p>Where the <code>ctorArguments</code> property specifies a list of match conditions based on constructor parameters and the <code>ctorNamedArguments</code> property specifies match conditions using named constructor arguments.</p>
</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dotnet/docfx/blob/main/docs/docs/dotnet-api-docs.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>
        
      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top">
      <div class="container-xxl">
        <div class="flex-fill">
          <span>Supported by the <a href="https://dotnetfoundation.org">.NET Foundation</a>. Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
        </div>
      </div>
    </footer>
  </body>
</html>