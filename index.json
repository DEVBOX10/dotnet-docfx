{
  "api/Microsoft.DocAsCode.Docset.html": {
    "href": "api/Microsoft.DocAsCode.Docset.html",
    "title": "Class Docset | docfx",
    "keywords": "Class Docset Provides access to a set of documentations and their associated configs, compilations and models. Inheritance Object Docset Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Microsoft.DocAsCode Assembly : Microsoft.DocAsCode.App.dll Syntax public static class Docset Methods | Improve this Doc View Source Build(String) Builds a docset specified by docfx.json config. Declaration public static Task Build(string configPath) Parameters Type Name Description String configPath The path to docfx.json config file. Returns Type Description Task A task to await for build completion."
  },
  "api/Microsoft.DocAsCode.html": {
    "href": "api/Microsoft.DocAsCode.html",
    "title": "Namespace Microsoft.DocAsCode | docfx",
    "keywords": "Namespace Microsoft.DocAsCode Classes Docset Provides access to a set of documentations and their associated configs, compilations and models."
  },
  "docs/config.html": {
    "href": "docs/config.html",
    "title": "Config | docfx",
    "keywords": "Config Docfx uses docfx.json as the config file for the site. Most docfx commands operate in a directory containing docfx.json . The build config determines what files are included in the site: { \"build\": { \"content\": [ { \"files\": \"**/*.{md,yml}\", \"exclude\": \"**/include/**\" } ], \"resource\": [ { \"files\": \"**/images/**\" } ] } } The content config defines glob patterns of files that are transformed to HTML by the build process. It is usually the markdown files and auto-generated API YAML files. The resource config defines static resources copied to output as is. URL Management URL is determined by the file path relative to docfx.json . Docfx uses “Ugly URLs”: a file named docs/urls.md is accessible from the docs/urls.html URL. To customize URL pattern for a directory, use the src property to remove the directory name from the URL, and use the dest property to insert an URL prefix: { \"build\": { \"content\": [ { \"files\": \"**/*.{md,yml}\", \"src\": \"articles\", \"dest\": \"docs\" } ] } } In this example, files in the articles directory uses docs as the base URL: The articles/getting-started/installation.md file is accessible by the docs/getting-started/installation.html URL. Metadata Metadata are attributes attached to an file. It helps shape the look and feel of a page and provides extra context to the article. To add metadata to an article, use \"YAML Front Matter\" markdown extension syntax: --- title: a title description: a description --- Some metadata attributes are consistent across a set of content. Use the globalMetadata property in docfx.json to apply the same metadata to all articles: { \"build\": { \"globalMetadata\": { \"_appTitle\": \"My App\" } } } To apply identical metadata values to a folder or a set of content, use the fileMetadata config: { \"build\": { \"fileMetadata\": { \"_appTitle\": { \"articles/dotnet/**/*.md\": \".NET\", \"articles/typescript/**/*.md\": \"TypeScript\" } } } } When the same metadata key is defined in multiple places, YAML Front Matter takes precedence over fileMetadata which in turn takes precedence over globalMetadata . Predefined Metadata Here is a list of predefined metadata recognized by the default docfx site template to customize basic site settings: Name Type Description _appTitle string A string append to every page title. _appFooter string The footer HTML. _appLogoPath string App logo URL path. _appFaviconPath string Favicon URL path. _enableSearch bool Whether to show the search box. _enableNewTab bool Whether to open external links in a new tab. _disableNavbar bool Whether to show the navigation bar. _disableBreadcrumb bool Whether to show the breadcrumb. _disableToc bool Whether to show the TOC. _disableAffix bool Whether to show the right rail. _noindex bool Whether to include in search results _disableContribution bool Whether to show the \"Improve this Doc\" and _\"View Source\" buttons. _gitContribute object Defines the repo and branch property of git links. _gitUrlPattern string URL pattern of git links. Tip Docfx produces the right git links for major CI pipelines including GitHub , GitLab , Azure Pipelines , AppVeyor , TeamCity , Jenkins . _gitContribute and _gitUrlPattern are optional on these platforms. Sitemap Docfx produces a sitemap.xml about the pages on your site for search engines like Google to crawl your site more efficiently. The sitemap option in docfx.json controls how sitemaps are generated: { \"build\": { \"sitemap\": { \"baseUrl\": \"https://dotnet.github.iodocfx\", \"priority\": 0.1, \"changefreq\": \"monthly\" } } } Where: baseUrl is the base URL for the website. It should start with http or https and end with a trailing slash. For example, https://dotnet.github.io/docfx/ . lastmod is the date of last modification of the page. If not specified, docfx sets the date to the build time. changefreq determines how frequently the page is likely to change. Valid values are always , hourly , daily , weekly , monthly , yearly , never . Default to daily . priority is the priority of this URL relative to other URLs on your site. Valid values range from 0.0 to 1.0. fileOptions is a per file config of the above options. The key is the file glob pattern and value is the sitemap options."
  },
  "docs/dotnet-api-docs.html": {
    "href": "docs/dotnet-api-docs.html",
    "title": ".NET API Docs | docfx",
    "keywords": ".NET API Docs Docfx converts XML documentation comments into rendered HTML documentations. Build from DLL, csproj or Source Code To add API docs for a .NET project, add a metadata section before the build section in docfx.json config: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\" }, \"build\": { \"content\": [{ \"files\": [ \"**/*.{md,yml}\" ] }] } } The docfx metadata command uses metadata config to produce .NET API YAML files at the dest directory for the docfx build command to turn into HTML files. The src property can be a glob pattern of DLL, csproj, or source code. When file extension is .dll , docfx produces API docs using the DLL and the side-by-side XML documentation file. Source code linking is not available in this mode. When file extension is .csproj , .vbproj , .fsproj or .sln , docfx builds the project and produces API docs based on project config and source code. Source code linking is available in this mode. Additional msbuild properties to build the projects can be specified in the properties config: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"properties\": { \"TargetFramework\": \"net6.0\" } }, } When file extension is .cs or .vb , docfx uses the latest .NET Core SDK installed on the machine to build the source code. References provided by Microsoft.NET.Sdk are available to the source code, additional references can be specified in the references config: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"references\": [ \"path-to-my-library.dll\" ] }, } Supported XML Tags Docfx supports Recommended XML tags for C# documentation comments . Warning Docfx parses XML documentation comment as markdown by default, writing XML documentation comments using markdown may cause rendering problems on places that do not support markdown, like in the Visual Studio intellisense window. To disable markdown parsing while processing XML tags, set shouldSkipMarkup to true : { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"shouldSkipMarkup\": true } } Filter APIs Docfx hides generated code or members marked as [EditorBrowsableAttribute] from API docs using filters. The default filter config contains common API patterns to exclude from docs. To add additional filter rules, add a custom YAML file and set the filter property in docfx.json to point to the custom YAML filter: { \"metadata\": { \"src\": [{ \"files\": [\"**/bin/Release/**.dll\"], \"src\": \"../\" }], \"dest\": \"api\", \"filter\": \"filterConfig.yml\" // <-- Path to custom filter config } } The filter config is a list of rules. A rule can include or exclude a set of APIs based on a pattern. The rules are processed sequentially and would stop when a rule matches. Filter by UID Every item in the generated API docs has a UID (a unique identifier calculated for each API) to filter against using regular expression. This example uses uidRegex to excludes all APIs whose uids start with Microsoft.DevDiv but not Microsoft.DevDiv.SpecialCase . apiRules: - include: uidRegex: ^Microsoft\\.DevDiv\\.SpecialCase - exclude: uidRegex: ^Microsoft\\.DevDiv Filter by Type This example exclude APIs whose uid starts with Microsoft.DevDiv and type is Type : apiRules: - exclude: uidRegex: ^Microsoft\\.DevDiv type: Type Supported value for type are: Namespace Class Struct Enum Interface Delegate Event Field Method Property Type : a Class , Struct , Enum , Interface or Delegate . Member : a Field , Event , Method or Property . API filter are hierarchical, if a namespace is excluded, all types/members defined in the namespace would also be excluded. Similarly, if a type is excluded, all members defined in the type would also be excluded. Filter by Attribute This example excludes all APIs which have AttributeUsageAttribute set to System.AttributeTargets.Class and the Inherited argument set to true : apiRules: - exclude: hasAttribute: uid: System.AttributeUsageAttribute ctorArguments: - System.AttributeTargets.Class ctorNamedArguments: Inherited: \"true\" Where the ctorArguments property specifies a list of match conditions based on constructor parameters and the ctorNamedArguments property specifies match conditions using named constructor arguments."
  },
  "docs/dotnet-yaml-format.html": {
    "href": "docs/dotnet-yaml-format.html",
    "title": ".NET API Docs YAML Format | docfx",
    "keywords": ".NET API Docs YAML Format This document describes the YAML file format to represent .NET API docs. The first line of the YAML file is the magic header ### YamlMime:ManagedReference . 1. Items The following .NET elements are defined as items in metadata: Namespaces Types, including class, struct, interface, enum, delegate Type members, including field, property, method, event Other elements such as parameters and generic parameters are not standalone items , they're part of other items . 2. Identifiers 2.1 Unique Identifiers For any item in .NET languages, its UID is defined by concatenating its parent 's UID and its own ID with a dot. The ID for each kind of item is defined in following sections. The basic principle here is to make ID format close to source code and easy for human reading. UID is similar to the document comment id, which is started with type prefix, for example, T: , or M: , but UID do not. There MUST NOT be any whitespace between method name, parentheses, parameters, and commas. 2.2 Spec Identifiers Spec identifier is another form of UID . It can spec a generic type with type arguments (for example, for parameters, return types or inheritances) and these UID s are unique in one yaml file. It is a simple modified Unique Identifiers, when it contains generic type arguments, it will use {Name} instead `N . For type parameter, it will be {Name} . And it also supports array and pointer. Example 2.2 Spec Identifier C#: namespace Foo { public class Bar { public unsafe List<String> FooBar<TArg>(int[] arg1, byte* arg2, TArg arg3, List<TArg[]> arg4) { return null; } } } YAML: references: - uid: System.Collections.Generic.List{System.String} - uid: System.Int32[] - uid: System.Byte* - uid: {TArg} - uid: System.Collections.Generic.List{{TArg}[]} 3. Namespaces For all namespaces, they are flat, e.i. namespaces do not have the parent namespace. So for any namespace, ID is always same with its UID . Example 3 Namespace C#: namespace System.IO { } YAML: uid: System.IO id: System.IO name: System.IO fullName: System.IO The children of namespace are all the visible types in the namespace. 4. Types Types include classes, structs, interfaces, enums, and delegates. They have following properties: summary, remarks, syntax, namespace, assemblies, inheritance. The parents of types are namespaces. The children of types are members. ID ID for a type is also its name . Example 4 Type C#: namespace System { public class String {} public struct Boolean {} public interface IComparable {} public enum ConsoleColor {} public delegate void Action(); } YAML: - uid: System.String id: String name.csharp: String fullName.csharp: System.String - uid: System.Boolean id: Boolean name.csharp: Boolean fullName.csharp: System.String - uid: System.IComparable id: IComparable name.csharp: IComparable fullName.csharp: System.IComparable - uid: System.ConsoleColor id: ConsoleColor name.csharp: ConsoleColor fullName.csharp: System.ConsoleColor - uid: System.Action id: Action name.csharp: Action fullName.csharp: System.Action 4.1 ID for Nested Types For nested types, ID is defined by concatenating the ID of all its containing types and the ID of itself, separated by a dot. The parent type of a nested type is its containing namespace, rather than its containing type. Example 4.1 Nested type C#: namespace System { public class Environment { public enum SpecialFolder {} } } YAML: uid: System.Environment.SpecialFolder id: Environment.SpecialFolder name.csharp: Environment.SpecialFolder fullName.csharp: System.Environment.SpecialFolder 4.2 Inheritance Only class contains inheritance, and the inheritance is a list of spec id. Example 4.2 Inheritance C#: namespace System.Collections.Generic { public class KeyedByTypeCollection<TItem> : KeyedCollection<Type, TItem> { } } YAML: uid : System.Collections.Generic.KeyedByTypeCollection`1 inheritance: - System.Collections.ObjectModel.KeyedCollection{System.Type,{TItem}} - System.Collections.ObjectModel.Collection{{TItem}} - System.Object 4.3 Syntax The syntax part for type contains declaration, and descriptions of type parameters for different languages. For delegates, it also contains descriptions of parameters and a return type. 5. Members Members include fields, properties, methods, and events. They have the following properties: summary, remarks, exceptions, and syntax. The parents of members are types. Members never have children, and all parameter types or return types are spec id. 5.1 Constructors The ID of a constructor is defined by #ctor , followed by the list of the UIDs of its parameter types: When a constructor does not have parameter, its ID MUST NOT end with parentheses. The syntax part for constructors contains a special language declaration, and descriptions of parameters. Example 5.1 Constructor C#: namespace System { public sealed class String { public String(); public String(char[] chars); } } YAML: - uid: System.String.#ctor id: #ctor name.csharp: String() fullName.csharp: System.String.String() - uid: System.String.#ctor(System.Char[]) id: #ctor(System.Char[]) name.csharp: String(Char[]) fullName.csharp: System.String.String(System.Char[]) 5.2 Methods The ID of a method is defined by its name, followed by the list of the UIDs of its parameter types: method_name(param1,param2,...) When a method does not have parameter, its ID MUST end with parentheses. The syntax part for method contains a special language declaration, and descriptions of type parameters for generic method, descriptions of parameters and return type. Example 5.2 Method C#: namespace System { public sealed class String { public String ToString(); public String ToString(IFormatProvider provider); } } YAML: - uid: System.String.ToString id: ToString name.csharp: ToString() fullName.csharp: System.String.ToString() - uid: System.String.ToString(System.IFormatProvider) id: ToString(System.IFormatProvider) name.csharp: ToString(IFormatProvider) fullName.csharp: System.String.ToString(System.IFormatProvider) 5.2.1 Explicit Interface Implementation The ID of an explicit interface implementation (EII) member MUST be prefixed by the UID of the interface it implements and replace . to # . Example 2.6 Explicit interface implementation (EII) C#: namespace System { using System.Collections; public sealed class String : IEnumerable { IEnumerator IEnumerable.GetEnumerator(); } } YAML: - uid: \"System.String.System#Collections#IEnumerable#GetEnumerator\" id: \"System#Collections#IEnumerable#GetEnumerator\" name.csharp: IEnumerable.GetEnumerator() fullName.csharp: System.String.System.Collections.IEnumerable.GetEnumerator() 5.4 Operator Overloads The IDs of operator overloads are same with the metadata name (for example, op_Equality ). The names of operator overloads are similar to MSDN, just remove op_ from the metadata name of the method. For instance, the name of the equals ( == ) operator is Equality . Type conversion operator can be considered a special operator whose name is the UID of the target type, with one parameter of the source type. For example, an operator that converts from string to int should be Explicit(System.String to System.Int32) . The syntax part for methods contains a special language declaration, descriptions of parameters and return type. Example 5.4 Operator overload namespace System { public struct Decimal { public static implicit operator Decimal(Char value); } public sealed class String { public static bool operator ==(String a, String b); } } YAML: - uid: System.Decimal.op_Implicit(System.Char)~System.Decimal id: op_Implicit(System.Char)~System.Decimal name.csharp: Implicit(Char to Decimal) fullName.csharp: System.Decimal.Implicit(System.Char to System.Decimal) - uid: System.String.op_Equality(System.String,System.String) id: op_Equality(System.String,System.String) name.csharp: Equality(String,String) fullName.csharp: System.String.Equality(System.String,System.String) Please check overloadable operators for all overloadable operators. 5.5 Field, Property or Event The ID of field, property or event is its name. The syntax part for field contains a special language declaration and descriptions of field type. For property, it contains a special language declaration, descriptions of parameters, and return type. For event, it contains a special language declaration and descriptions of event handler type. Example 5.5 Field, Property and Event C#: namespace System { public sealed class String { public static readonly String Empty; public int Length { get; } } public static class Console { public static event ConsoleCancelEventHandler CancelKeyPress; } } YAML: - uid: System.String.Empty id: Empty name.csharp: Empty fullName.csharp: System.String.Empty - uid: System.String.Length id: Length name.csharp: Length fullName.csharp: System.String.Length - uid: System.Console.CancelKeyPress id: CancelKeyPress name.csharp: CancelKeyPress fullName.csharp: System.Console.CancelKeyPress 5.6 Indexer Indexer operator's name is metadata name, by default, it is Item , with brackets and parameters. Example 5.6 Indexer namespace System.Collections { public interface IList { object this[int index] { get; set; } } } YAML: - uid: \"System.Collections.IList.Item[System.Int32]\" id: \"Item[System.Int32]\" name.csharp: Item[Int32] fullName.csharp: System.Collections.IList.Item[System.Int32] 6. Generics The ID of a generic type is its name with followed by `n , n and the count of generic type count, which is the same as the rule for document comment ID. For example, Dictionary`2 . The ID of a generic method uses postfix ``n , n is the count of in method parameters, for example, System.Tuple.Create``1(``0) . Example 2.7 Generic namespace System { public static class Tuple { public static Tuple<T1> Create<T1>(T1 item1); public static Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2); } } YAML: - uid: System.Tuple.Create``1(``0) id: Create``1(``0) name.csharp: Create<T1>(T1) fullName.csharp: System.Tuple.Create<T1>(T1) - uid: System.Tuple.Create``2(``0,``1) id: Create``2(``0,``1) name.csharp: Create<T1,T2>(T1,T2) fullName.csharp: System.Tuple.Create<T1,T2>(T1,T2) 7. Reference The reference contains the following members: name, fullName, summary, isExternal, href, and more. The UID in reference can be a Spec Id , then it contains one more member: spec. The spec in reference is very like a list of lightweight references, it describes how to compose the generic type in some special language. Example 7 spec for references YAML: references: - uid: System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.List{System.Int32}} name.csharp: Dictionary<String, List<Int32>> fullName.csharp: System.Collections.Generic.Dictionary<System.String, System.Collections.Generic.List<System.Int32>> spec.csharp: - uid: System.Collections.Generic.Dictionary`2 name: Dictionary fullName: System.Collections.Generic.Dictionary isExternal: true - name: < fullName: < - uid: System.String name: String fullName: System.String isExternal: true - name: ', ' fullName: ', ' - uid: System.Collections.Generic.List`1 name: List fullName: System.Collections.Generic.List isExternal: true - name: < fullName: < - uid: System.Int32 name: Int32 fullName: System.Int32 isExternal: true - name: '>' fullName: '>' - name: '>' fullName: '>'"
  },
  "docs/markdown.html": {
    "href": "docs/markdown.html",
    "title": "Markdown | docfx",
    "keywords": "Markdown Markdown is a lightweight markup language with plain text formatting syntax. Docfx supports CommonMark compliant Markdown parsed through the Markdig parsing engine. Docfx supports additional markdown syntax that provide richer content. These syntax are specific to docfx and won't be rendered elsewhere like GitHub. Alerts Alerts are block quotes that render with colors and icons that indicate the significance of the content. The following alert types are supported: > [!NOTE] > Information the user should notice even if skimming. > [!TIP] > Optional information to help a user be more successful. > [!IMPORTANT] > Essential information required for user success. > [!CAUTION] > Negative potential consequences of an action. > [!WARNING] > Dangerous certain consequences of an action. They look like this in rendered page: Note Information the user should notice even if skimming. Tip Optional information to help a user be more successful. Important Essential information required for user success. Caution Negative potential consequences of an action. Warning Dangerous certain consequences of an action. Video You can embed a video in your page by using the following Markdown syntax: > [!Video embed_link] Example: > [!Video https://www.youtube.com/embed/Sz1lCeedcPI] This will be rendered as: Include Markdown Files Where markdown files need to be repeated in multiple articles, you can use an include file. The includes feature replace the reference with the contents of the included file at build time. You can reuse a common text snippet within a sentence using inline include: Text before [!INCLUDE [<title>](<filepath>)] and after. Or reuse an entire Markdown file as a block, nested within a section of an article. Block include is on its own line: [!INCLUDE [<title>](<filepath>)] Where <title> is the name of the file and <filepath> is the relative path to the file. Included markdown files needs to be excluded from build, they are usually placed in the /includes folder. Code Snippet There are several ways to include code in an article. The code snippet syntax replaces code from another file: [!code-csharp[](Program.cs)] You can include selected lines from the code snippet using region or line range syntax: [!code-csharp[](Program.cs#region)] [!code-csharp[](Program.cs#L12-L16)] Code snippets are indicated by using a specific link syntax described as follows: [!code-<language>[](<filepath><query-options>)] Where <language> is the syntax highlighting language of the code and <filepath> is the relative path to the markdown file. Highlight Selected Lines Code Snippets typically include more code than necessary in order to provide context. It helps readability when you highlight the key lines that you're focusing on. To highlight key lines, use the highlight query options: [!code-csharp[](Program.cs?highlight=2,5-7,9-)] The example highlights lines 2, line 5 to 7 and lines 9 to the end of the file. Tabs Tabs enable content that is multi-faceted. They allow sections of a document to contain variant content renderings and eliminates duplicate content. Here's an example of the tab experience: Linux Windows Content for Linux... Content for Windows... The above tab group was created with the following syntax: # [Linux](#tab/linux) Content for Linux... # [Windows](#tab/windows) Content for Windows... --- Tabs are indicated by using a specific link syntax within a Markdown header. The syntax can be described as follows: # [Tab Display Name](#tab/tab-id) A tab starts with a Markdown header, # , and is followed by a Markdown link []() . The text of the link will become the text of the tab header, displayed to the customer. In order for the header to be recognized as a tab, the link itself must start with #tab/ and be followed by an ID representing the content of the tab. The ID is used to sync all same-ID tabs across the page. Using the above example, when a user selects a tab with the link #tab/windows , all tabs with the link #tab/windows on the page will be selected. Dependent tabs It's possible to make the selection in one set of tabs dependent on the selection in another set of tabs. Here's an example of that in action: .NET .NET TypeScript TypeScript REST API .NET content for Linux... .NET content for Windows... TypeScript content for Linux... TypeScript content for Windows... REST API content, independent of platform... Notice how changing the Linux/Windows selection above changes the content in the .NET and TypeScript tabs. This is because the tab group defines two versions for each .NET and TypeScript, where the Windows/Linux selection above determines which version is shown for .NET/TypeScript. Here's the markup that shows how this is done: # [.NET](#tab/dotnet/linux) .NET content for Linux... # [.NET](#tab/dotnet/windows) .NET content for Windows... # [TypeScript](#tab/typescript/linux) TypeScript content for Linux... # [TypeScript](#tab/typescript/windows) TypeScript content for Windows... # [REST API](#tab/rest) REST API content, independent of platform... ---"
  },
  "docs/pdf.html": {
    "href": "docs/pdf.html",
    "title": "Create PDF Files | docfx",
    "keywords": "Create PDF Files Docfx produces PDF files based on the TOC structure. Install wkhtmltopdf To build PDF files, first install wkhtmltopdf by downloading the latest binary from the official site or install using chocolatey: choco install wkhtmltopdf . Make sure the wkhtmltopdf command is added to PATH environment variable and is available in the terminal. PDF Config Add a pdf section in docfx.json : { \"pdf\": { \"content\": [{ \"files\": [ \"**/*.{md,yml}\" ] }], \"wkhtmltopdf\": { \"additionalArguments\": \"--enable-local-file-access\" }, } } Most of the config options are the same as build config. The wkhtmltopdf config contains additional details to control wkhtmltopdf behavior: filePath : Path to wkhtmltopdf.exe . additionalArguments : Additional command line arguments passed to wkhtmltopdf . Usually needs --enable-local-file-access to allow access to local files. Running docfx command againt the above configuration produces a PDF file for every TOC included in the content property. The PDF files are placed under the _site_pdf folder based on the TOC name. See this sample on an example PDF config. Add Cover Page A cover page is the first PDF page before the TOC page. To add a cover page, add a cover.md file alongside toc.yml . The content of cover.md will be rendered as the PDF cover page."
  },
  "docs/rest-api-docs.html": {
    "href": "docs/rest-api-docs.html",
    "title": "Add REST API docs | docfx",
    "keywords": "Add REST API docs Docfx generates REST API documentation from Swagger 2.0 files. To add REST API docs, include the swagger JSON file to the build config in docfx.json : { \"metadata\": { \"src\": [ \"../src/**/bin/Release/**.dll\" ], \"dest\": \"api\" }, \"build\": { \"content\": [{ \"files\": [ \"**/*.swagger.json\" ] // <-- Include swagger JSON files }] } } Each swagger file produces one output HTML file. Organize REST APIs using Tags APIs can be organized using the Tag Object . An API can be associated with one or more tags. Untagged APIs are put in the Other apis section. This example defines the Basic and Advanced tags and organize APIs using the two tags. The x-bookmark-id property specifies the URL fragment for the tag. { \"swagger\": \"2.0\", \"info\": { \"title\": \"Contacts\", \"version\": \"1.6\" }, \"host\": \"microsoft.com\", \"basePath\": \"/docfx\", \"schemes\": [ \"https\" ], \"tags\": [ { \"name\": \"Basic\", \"x-bookmark-id\": \"BasicBookmark\", \"description\": \"Basic description\" }, { \"name\": \"Advanced\", \"description\": \"Advanced description\" } ], \"paths\": { \"/contacts\": { \"get\": { \"operationId\": \"get_contacts\", \"tags\": [ \"Basic\", \"Advanced\" ] }, \"set\": { \"operationId\": \"set_contacts\", \"tags\": [ \"Advanced\" ] }, \"delete\": { \"operationId\": \"delete_contacts\" } } } } The above example produces the following layout: Basic ├─ get_contacts Advanced ├─ get_contacts ├─ set_contacts Other APIs ├─ delete_contacts"
  },
  "docs/table-of-contents.html": {
    "href": "docs/table-of-contents.html",
    "title": "Table of Contents | docfx",
    "keywords": "Table of Contents A table of contents (TOC) defines the structure of a set of documents. YAML TOC To add a TOC, create a file named toc.yml . Here's the structure for a simple YAML TOC: items: - name: Tutorial items: - name: Introduction href: tutorial.md - name: Step 1 href: step-1.md - name: Step 2 href: step-2.md - name: Step 3 href: step-3.md The YAML document is a tree of TOC nodes, each of which has these properties: name : The display name for the TOC node. href : The path the TOC node leads to. Optional because a node can exist just to parent other nodes. items : If a node has children, they're listed in the items array. Navigation Bar The toc.yml file in the docfx.json folder will be used to fill the content of the navigation bar at the top of the page. Nested TOCs To nest a TOC within another TOC, set the href property to point to the toc.yml file that you want to nest. You can also use this structure as a way to reuse a TOC structure in one or more TOC files. Consider the following two toc.yml files: toc.yml : items: - name: Overview href: overview.md - name: Reference href: api/toc.yml api/toc.yml : items: - name: System.String href: system.string.yml - name: System.Float href: system.float.yml This structure renders as follows: Overview Reference ├─ System.String ├─ System.Float"
  },
  "docs/template.html": {
    "href": "docs/template.html",
    "title": "Template | docfx",
    "keywords": "Template Template defines the appearance of the website. Docfx ships a default website template with the same look and feel as this site. Additional templates are available at the Template Gallary . Create a Custom Template To build your own template, create a new folder and add it to templates config in docfx.json : { \"build\": { \"templates\": [ \"default\", \"my-template\" // <-- Path to custom template ] } } Add your custom CSS file to styles/main.css and JavaScript file to styles/main.js . Docfx loads these 2 files and use them to style the website. This is an example stylesheet that adjust the font size of article headers: /* file: styles/main.css */ article h1 { font-size: 40px; } Custom HTML Templates In addition to CSS and JavaScript, you can customize how docfx generates HTML using Mustache Templates . Create a partials/footer.tmpl.partial file to replace the footer. This example update the footer to show a GitHub Follow button. <footer> <a class=\"github-button\" href=\"{{source.remote.repo}}\" data-size=\"large\" aria-label=\"Follow\">Follow</a> <script async defer src=\"https://buttons.github.io/buttons.js\"></script> </footer> The list of customizable HTML components are: partials/logo.tmpl.partial : The logo in the header. partials/footer.tmpl.partial : The footer at the bottom of the page. partials/affix.tmpl.partial : The right rail. partials/breadcrumb.tmpl.partial : The breadcrumb bar. Template Variables Metadata and other properties are available to the template engine. To see the template JSON input model, build with --exportRawModel command line option. Here are some predefined variables available to the template: Name Description _rel The relative path of the root output folder from current output file. For example, if the output file is a/b/c.html from root output folder, then the value is ../../ . _path The path of current output file starting from root output folder. _navPath The relative path of the root TOC file from root output folder, if exists. The root TOC file stands for the TOC file in root output folder. For example, if the output file is html file, the value is toc.html . _navRel The relative path from current output file to the root TOC file, if exists. For example, if the root TOC file is toc.html from root output folder, the value is empty. _navKey The original file path of the root TOC file starting with ~/ . ~/ stands for the folder where docfx.json is in, for example, ~/toc.md . _tocPath The relative path of the TOC file that current output file belongs to from root output folder, if current output file is in that TOC file. If current output file is not defined in any TOC file, the nearest TOC file is picked. _tocRel The relative path from current output file to its TOC file. For example, if the TOC file is a/toc.html from root output folder, the value is ../ . _tocKey The original file path of the TOC file starting with ~/ . ~/ stands for the folder where docfx.json is in, for example, ~/a/toc.yml ."
  },
  "extensions/packages.html": {
    "href": "extensions/packages.html",
    "title": "Packages |",
    "keywords": ""
  },
  "extensions/templates.html": {
    "href": "extensions/templates.html",
    "title": "Templates |",
    "keywords": ""
  },
  "extensions/tools.html": {
    "href": "extensions/tools.html",
    "title": "Tools |",
    "keywords": ""
  },
  "index.html": {
    "href": "index.html",
    "title": "Quick Start | docfx",
    "keywords": "Quick Start Build your technical documentation site with docfx. Converts .NET assembly, XML code comment, REST API Swagger files and markdown into rendered HTML pages, JSON model or PDF files. Create a New Website In this section we will build a simple documentation site on your local machine. Prerequisites Familiarity with the command line Install .NET SDK 6.0 or higher Make sure you have .NET SDK installed, then open a terminal and enter the following command to install the latest docfx: dotnet tool update -g docfx To create a new docset, run: docfx init --quiet This command creates a new docset under the docfx_project directory. To build the docset, run: docfx docfx_project/docfx.json --serve Now you can preview the website on http://localhost:8080 . To preview your local changes, save changes then run this command in a new terminal to rebuild the website: docfx docfx_project/docfx.json Publish to GitHub Pages Docfx produces static HTML files under the _site folder ready for publishing to any static site hosting servers. To publish to GitHub Pages: Enable GitHub Pages . Upload _site folder to GitHub Pages using GitHub actions. This example uses peaceiris/actions-gh-pages to publish to the gh-pages branch: # Your GitHub workflow file under .github/workflows/ jobs: publish-docs: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-dotnet@v3 with: dotnet-version: 6.x - run: dotnet install -g docfx - run: docfx docs/docfx.json - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: docs/_site Use the NuGet Library You can also use docfx as a NuGet library: <PackageReference Include=\"Microsoft.DocAsCode.App\" Version=\"2.60.0\" /> Then build a docset using: await Microsoft.DocAsCode.Docset.Build(\"docfx.json\"); See API References for additional APIs. Next Steps Write Articles Organize Contents Configure Website Add .NET API Docs"
  },
  "README.html": {
    "href": "README.html",
    "title": "| docfx",
    "keywords": "Documentation project uses docfx.console nuget package to generate documentation for docfx project, along with conceputal files, with docfx.json to provide configuration for docfx ."
  }
}